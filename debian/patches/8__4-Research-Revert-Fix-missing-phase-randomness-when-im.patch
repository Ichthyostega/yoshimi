From: Ichthyostega <prg@ichthyostega.de>
Date: Sat, 1 Oct 2022 01:04:05 +0200
Subject: Research: Revert Fix missing phase randomness when importing sub
 voices.

Not sure if this has an audible effect on existing instruments;
just can not get rid of the doubts...

This reverts commit 69c6b8641618d73eb9516fd6a314e5d934e811c4.

    Fix missing phase randomness when importing sub voices.

    This was working for normal oscillators at one point, but was broken
    when the live editing was introduced. For modulators I believe it has
    never worked. Depending on how the sound is set up, the effect can be
    very subtle, so it took me a long time to discover it.

    However, there is one scenario where it is very audible. Set the
    second voice to import from the first voice (doesn't matter which
    waveform), and set unison of the second voice to 50. Make sure phase
    randomness is at 100%. This produces a loud volume spike at the
    beginning of the sound because all the waveforms' phases line up
    exactly, before they start drifting apart. This should not happen when
    randomness is on.

    This required several fixes. First and foremost, we were not even
    storing the phase offset for modulators, so introduce that in the
    constructor.

    Second, a problem is that the assignment of phases in the parent voice
    was happening too late; the sub voice was created, and its phase
    assigned, before the parent voice had calculated any phase. Because of
    live editing, most of the phase calculations now happens in
    computeNoteParameters(), which executes on every cycle. However, it
    would be unreasonably expensive to call this early, because we still
    have to call it again as part of the normal cycle. Then we would have
    to call it twice for every note, and it's not a cheap function.

    So instead, split out the part that deals with the phases into
    separate functions, and call them when we need them instead. This is
    still two calls, but much cheaper than computeNoteParameters().

    And finally, the code was restructured slightly to be make sure we
    call synth->numRandom() only once, while the rest of the calculation
    we can call as many times as we want. Otherwise every cycle would have
    a new random phase, which is just noise.

    Signed-off-by: Kristian Amlie <kristian@amlie.name>
---
 src/Synth/ADnote.cpp | 173 +++++++++++++++++++++++----------------------------
 src/Synth/ADnote.h   |   2 -
 2 files changed, 77 insertions(+), 98 deletions(-)

diff --git a/src/Synth/ADnote.cpp b/src/Synth/ADnote.cpp
index 4d3d02b..bc8282c 100644
--- a/src/Synth/ADnote.cpp
+++ b/src/Synth/ADnote.cpp
@@ -148,13 +148,11 @@ ADnote::ADnote(ADnoteParameters& adpars_, Controller& ctl_, Note note_, bool por
     , topVoice{topVoice_}
     , parentFMmod{parentFMmod_}
 {
-    // Start phase for sub-Voices should be negative so that the zero phase in
-    // the first cycle will result in a positive phase change.
     int phase = (topVoice==this)? 0 : synth.oscilsize - phaseOffset;
-    for (int nvoice = 0; nvoice < NUM_VOICES; ++nvoice) {
+             // Start phase for sub-Voices should be negative
+             // so that the zero phase in the first cycle will result in a positive phase change.
+    for (int nvoice = 0; nvoice < NUM_VOICES; ++nvoice)
         NoteVoicePar[nvoice].phaseOffset = phase;
-        NoteVoicePar[nvoice].fmPhaseOffset = phase;
-    }
 
     construct();
 }
@@ -562,6 +560,20 @@ void ADnote::construct()
             NoteVoicePar[nvoice].oscilSmp.attachReference(topVoice->NoteVoicePar[nvoice].oscilSmp);
         }
 
+        int oscposhi_start;
+        if (NoteVoicePar[nvoice].voice == -1)
+            oscposhi_start = adpars.VoicePar[vc].OscilSmp->getPhase();
+        else
+            oscposhi_start = 0;
+        int kth_start = oscposhi_start;
+        for (int k = 0; k < unison; ++k)
+        {
+            oscposhi[nvoice][k] = kth_start % synth.oscilsize;
+            // put random starting point for other subvoices
+            kth_start = oscposhi_start + (int)(synth.numRandom() * adpars.VoicePar[nvoice].Unison_phase_randomness
+                                        / 127.0f * (synth.oscilsize - 1));
+        }
+
         if (adpars.VoicePar[nvoice].Type != 0)
             NoteVoicePar[nvoice].fmEnabled = NONE;
         else
@@ -649,8 +661,6 @@ void ADnote::initSubVoices(void)
 
         if (NoteVoicePar[nvoice].voice != -1)
         {
-            computePhaseOffsets(nvoice);
-
             subVoice[nvoice].reset(new unique_ptr<ADnote>[unison_size[nvoice]]);
             for (size_t k = 0; k < unison_size[nvoice]; ++k)
             {
@@ -665,8 +675,6 @@ void ADnote::initSubVoices(void)
 
         if (NoteVoicePar[nvoice].fmVoice != -1)
         {
-            computeFMPhaseOffsets(nvoice);
-
             bool voiceForFM = NoteVoicePar[nvoice].fmEnabled == FREQ_MOD;
             subFMVoice[nvoice].reset(new unique_ptr<ADnote>[unison_size[nvoice]]);
             for (size_t k = 0; k < unison_size[nvoice]; ++k) {
@@ -906,53 +914,35 @@ void ADnote::initParameters(void)
         if (adpars.VoicePar[nvoice].PFilterLfoEnabled)
             NoteVoicePar[nvoice].filterLFO.reset(new LFO{adpars.VoicePar[nvoice].FilterLfo, note.freq, &synth});
 
-        int kth_start = 0;
-        for (size_t k = 0; k < unison_size[nvoice]; ++k)
-        {
-            oscposhi[nvoice][k] = kth_start;
-            // put random starting point for other subvoices
-            kth_start = (int)(synth.numRandom() * adpars.VoicePar[nvoice].Unison_phase_randomness
-                              / 127.0f * (synth.oscilsize - 1));
-        }
-
         // Voice Modulation Parameters Init
-        if (NoteVoicePar[nvoice].fmEnabled != NONE)
+        if (NoteVoicePar[nvoice].fmEnabled != NONE
+           && NoteVoicePar[nvoice].fmVoice < 0)
         {
-            if (NoteVoicePar[nvoice].fmVoice < 0)
-            {
-                int vc = nvoice;
-                if (adpars.VoicePar[nvoice].PextFMoscil != -1)
-                    vc = adpars.VoicePar[nvoice].PextFMoscil;
+            // Perform Anti-aliasing only on MORPH or RING MODULATION
 
-                if (subVoiceNr == -1) {
-                    // this voice maintains its own oscil wavetable...
-                    NoteVoicePar[nvoice].fmSmp.allocateWaveform(synth.oscilsize);
+            int vc = nvoice;
+            if (adpars.VoicePar[nvoice].PextFMoscil != -1)
+                vc = adpars.VoicePar[nvoice].PextFMoscil;
 
-                    adpars.VoicePar[nvoice].FMSmp->newrandseed();
-                    if (!adpars.GlobalPar.Hrandgrouping)
-                        adpars.VoicePar[vc].FMSmp->newrandseed();
+            if (subVoiceNr == -1) {
+                // this voice maintains its own oscil wavetable...
+                NoteVoicePar[nvoice].fmSmp.allocateWaveform(synth.oscilsize);
 
-                } else {
-                    // If subvoice use oscillator from original voice.
-                    NoteVoicePar[nvoice].fmSmp.attachReference(topVoice->NoteVoicePar[nvoice].fmSmp);
-                }
+                adpars.VoicePar[nvoice].FMSmp->newrandseed();
+                if (!adpars.GlobalPar.Hrandgrouping)
+                    adpars.VoicePar[vc].FMSmp->newrandseed();
 
-                for (size_t k = 0; k < unison_size[nvoice]; ++k)
-                    oscposhiFM[nvoice][k] =
-                        (oscposhi[nvoice][k] + adpars.VoicePar[vc].FMSmp->
-                         getPhase()) % synth.oscilsize;
             } else {
-                for (size_t k = 0; k < unison_size[nvoice]; ++k)
-                    oscposhiFM[nvoice][k] = oscposhi[nvoice][k];
+                // If subvoice use oscillator from original voice.
+                NoteVoicePar[nvoice].fmSmp.attachReference(topVoice->NoteVoicePar[nvoice].fmSmp);
             }
-        }
 
-        // Offset by oscillator phase.
-        if (NoteVoicePar[nvoice].voice == -1) {
-            int oscposhi_start;
-            oscposhi_start = adpars.VoicePar[nvoice].OscilSmp->getPhase();
             for (size_t k = 0; k < unison_size[nvoice]; ++k)
-                oscposhi[nvoice][k] = (oscposhi[nvoice][k] + oscposhi_start) % synth.oscilsize;
+                oscposhiFM[nvoice][k] =
+                    (oscposhi[nvoice][k] + adpars.VoicePar[vc].FMSmp->
+                     getPhase()) % synth.oscilsize;
+
+            NoteVoicePar[nvoice].fmPhaseOffset = 0;
         }
 
         if (adpars.VoicePar[nvoice].PFMFreqEnvelopeEnabled != 0)
@@ -1129,25 +1119,51 @@ void ADnote::computeNoteParameters(void)
             NoteVoicePar[nvoice].oscilSmp.fillInterpolationBuffer();
         }
 
+        int new_phase_offset = (int)((adpars.VoicePar[nvoice].Poscilphase - 64.0f)
+                                    / 128.0f * synth.oscilsize + synth.oscilsize * 4);
+        int phase_offset_diff = new_phase_offset - NoteVoicePar[nvoice].phaseOffset;
+        for (int k = 0; k < unison; ++k) {
+            oscposhi[nvoice][k] = (oscposhi[nvoice][k] + phase_offset_diff) % synth.oscilsize;
+            if (oscposhi[nvoice][k] < 0)
+                // This is necessary, because C '%' operator does not always
+                // return a positive result.
+                oscposhi[nvoice][k] += synth.oscilsize;
+        }
+        NoteVoicePar[nvoice].phaseOffset = new_phase_offset;
+
         if (NoteVoicePar[nvoice].fmEnabled != NONE
-            && NoteVoicePar[nvoice].fmVoice < 0
-            && subVoiceNr == -1) {
-            int vc = nvoice;
-            if (adpars.VoicePar[nvoice].PextFMoscil != -1)
-                vc = adpars.VoicePar[nvoice].PextFMoscil;
+            && NoteVoicePar[nvoice].fmVoice < 0)
+        {
+            if (subVoiceNr == -1) {
+                int vc = nvoice;
+                if (adpars.VoicePar[nvoice].PextFMoscil != -1)
+                    vc = adpars.VoicePar[nvoice].PextFMoscil;
 
-            float freqtmp = 1.0f;
-            if (adpars.VoicePar[vc].POscilFM->Padaptiveharmonics != 0
-                || (NoteVoicePar[nvoice].fmEnabled == MORPH)
-                || (NoteVoicePar[nvoice].fmEnabled == RING_MOD))
-                freqtmp = getFMVoiceBaseFreq(nvoice);
+                float freqtmp = 1.0f;
+                if (adpars.VoicePar[vc].POscilFM->Padaptiveharmonics != 0
+                    || (NoteVoicePar[nvoice].fmEnabled == MORPH)
+                    || (NoteVoicePar[nvoice].fmEnabled == RING_MOD))
+                    freqtmp = getFMVoiceBaseFreq(nvoice);
 
-            adpars.VoicePar[vc].FMSmp->getWave(NoteVoicePar[nvoice].fmSmp, freqtmp);
-            NoteVoicePar[nvoice].fmSmp.fillInterpolationBuffer();
-        }
+                adpars.VoicePar[vc].FMSmp->getWave(NoteVoicePar[nvoice].fmSmp, freqtmp);
+                NoteVoicePar[nvoice].fmSmp.fillInterpolationBuffer();
+            }
 
-        computePhaseOffsets(nvoice);
-        computeFMPhaseOffsets(nvoice);
+            int new_FMphase_offset = (int)((adpars.VoicePar[nvoice].PFMoscilphase - 64.0f)
+                                         / 128.0f * synth.oscilsize_f
+                                         + synth.oscilsize_f * 4.0f);
+            int FMphase_offset_diff = new_FMphase_offset - NoteVoicePar[nvoice].fmPhaseOffset;
+            for (size_t k = 0; k < unison_size[nvoice]; ++k)
+            {
+                oscposhiFM[nvoice][k] += FMphase_offset_diff;
+                oscposhiFM[nvoice][k] %= synth.oscilsize;
+                if (oscposhiFM[nvoice][k] < 0)
+                    // This is necessary, because C '%' operator does not always
+                    // return a positive result.
+                    oscposhiFM[nvoice][k] += synth.oscilsize;
+            }
+            NoteVoicePar[nvoice].fmPhaseOffset = new_FMphase_offset;
+        }
 
         bool is_pwm = NoteVoicePar[nvoice].fmEnabled == PW_MOD;
 
@@ -1273,41 +1289,6 @@ void ADnote::computeNoteParameters(void)
     }
 }
 
-void ADnote::computePhaseOffsets(int nvoice)
-{
-    int new_phase_offset = (int)((adpars.VoicePar[nvoice].Poscilphase - 64.0f)
-                                / 128.0f * synth.oscilsize + synth.oscilsize * 4);
-    int phase_offset_diff = new_phase_offset - NoteVoicePar[nvoice].phaseOffset;
-    for (size_t k = 0; k < unison_size[nvoice]; ++k) {
-        oscposhi[nvoice][k] = (oscposhi[nvoice][k] + phase_offset_diff) % synth.oscilsize;
-        if (oscposhi[nvoice][k] < 0)
-            // This is necessary, because C '%' operator does not always
-            // return a positive result.
-            oscposhi[nvoice][k] += synth.oscilsize;
-    }
-    NoteVoicePar[nvoice].phaseOffset = new_phase_offset;
-}
-
-void ADnote::computeFMPhaseOffsets(int nvoice)
-{
-    if (NoteVoicePar[nvoice].fmEnabled != NONE) {
-        int new_FMphase_offset = (int)((adpars.VoicePar[nvoice].PFMoscilphase - 64.0f)
-                                     / 128.0f * synth.oscilsize_f
-                                     + synth.oscilsize_f * 4.0f);
-        int FMphase_offset_diff = new_FMphase_offset - NoteVoicePar[nvoice].fmPhaseOffset;
-        for (size_t k = 0; k < unison_size[nvoice]; ++k)
-        {
-            oscposhiFM[nvoice][k] += FMphase_offset_diff;
-            oscposhiFM[nvoice][k] %= synth.oscilsize;
-            if (oscposhiFM[nvoice][k] < 0)
-                // This is necessary, because C '%' operator does not always
-                // return a positive result.
-                oscposhiFM[nvoice][k] += synth.oscilsize;
-        }
-        NoteVoicePar[nvoice].fmPhaseOffset = new_FMphase_offset;
-    }
-}
-
 // Get Voice's Modullator base frequency
 float ADnote::getFMVoiceBaseFreq(int nvoice)
 {
diff --git a/src/Synth/ADnote.h b/src/Synth/ADnote.h
index ed7e0a3..fb6a168 100644
--- a/src/Synth/ADnote.h
+++ b/src/Synth/ADnote.h
@@ -166,8 +166,6 @@ class ADnote
         void computeUnisonFreqRap(int nvoice);
         void computeNoteParameters(void);
         void computeWorkingParameters(void);
-        void computePhaseOffsets(int nvoice);
-        void computeFMPhaseOffsets(int nvoice);
         void initParameters(void);
         void initSubVoices(void);
         void killVoice(int nvoice);
