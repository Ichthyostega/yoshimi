# data file for the Fltk User Interface Designer (fluid)
version 1.0110
header_name {.h}
code_name {.cc}
comment {//
// Copyright 2009, Alan Calvert
//
// This file is part of yoshimi, which is free software: you can
// redistribute it and/or modify it under the terms of the GNU General
// Public License as published by the Free Software Foundation, either
// version 3 of the License, or (at your option) any later version.
//
// yoshimi is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with yoshimi.  If not, see <http://www.gnu.org/licenses/>.} {in_source in_header
}

decl {\#include <FL/x.H>} {public
}

decl {\#include <string>} {public
}

decl {using namespace std;} {public
}

decl {\#include "Misc/Master.h"} {public
}

decl {\#include "Misc/Config.h"} {public
}

decl {\#include "MasterUI.h"} {public
}

decl {pthread_t pthreadGui = 0;} {global
}

Function {guiThread(void* arg)} {private return_type {static void*}
} {
  code {while (!Pexitprogram)
    {
      Runtime.checkInterrupted();
      if (!Runtime.LogList.empty())
      {
        if (Runtime.LogList.front().size())
          guiMaster->Log(Runtime.LogList.front());
        Runtime.LogList.pop_front();
      }
      //if (Fl::ready())
        Fl::wait();
      //else
        usleep(1666);
    }
    return NULL;} {}
}

Function {noguiThread(void* arg)} {private return_type {static void*}
} {
  code {
    while (!Pexitprogram)
    {
      Runtime.checkInterrupted();
      usleep(66666);;
    }
    return NULL;
  } {}
}

Function {startGuiThread(bool show_gui)} {return_type bool
} {
  code {
    if (show_gui)
    {
      //Fl::visual(FL_INDEX|FL_RGB8);
      //fl_open_display();
      guiMaster->Init();
    }
    int chk;
    pthread_attr_t attr;
    if ((chk = pthread_attr_init(&attr)))
    {
        Runtime.Log("Failed to initialise gui thread attributes: " + asString(chk));
        return false;
    }
    if ((chk = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED)))
    {
        Runtime.Log("Failed to set gui thread detach state: " + asString(chk));
        return false;
    }
    if (show_gui)
    {
      if ((chk = pthread_create(&pthreadGui, &attr, guiThread, NULL)))
      {
        Runtime.Log("Failed to start gui thread: " + asString(chk));
        return false;
      }
    }
    else if ((chk = pthread_create(&pthreadGui, &attr, noguiThread, NULL)))
    {
      Runtime.Log("Failed to start gui thread: " + asString(chk));
      return false;
    }
    return true;
  } {}
}

Function {interruptedCheck(void* arg)} {private return_type {static void}
} {
  code {
    Runtime.checkInterrupted();
    Fl::repeat_timeout (1.0, interruptedCheck);
  } {}
}

Function {stopGuiThread(void)} {return_type void
} {
  code {Pexitprogram = true;
    pthread_cancel(pthreadGui);} {}
}
