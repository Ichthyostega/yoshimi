# data file for the Fltk User Interface Designer (fluid)
version 1.0109 
header_name {.h} 
code_name {.cc}
comment {WidgetPDial.h} {not_in_source in_header
}
comment {WidgetPDial.cc} {in_source not_in_header
}

comment {//
// Original ZynAddSubFX author Nasca Octavian Paul
// Copyright (C) 2002-2005 Nasca Octavian Paul
// Copyright 2009, Alan Calvert
//
// This file is part of yoshimi, which is free software: you can redistribute
// it and/or modify it under the terms of version 2 of the GNU General Public
// License as published by the Free Software Foundation.
//
// yoshimi is distributed in the hope that it will be useful, but WITHOUT ANY
// WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
// FOR A PARTICULAR PURPOSE.   See the GNU General Public License (version 2 or
// later) for more details.
//
// You should have received a copy of the GNU General Public License along with
// yoshimi; if not, write to the Free Software Foundation, Inc., 51 Franklin
// Street, Fifth Floor, Boston, MA  02110-1301, USA.
//
// This file is a derivative of the ZynAddSubFX original, modified October 2009
// along with yoshimi.  If not, see <http://www.gnu.org/licenses/>.
//} {in_source in_header
}

decl {\#include <FL/Fl_Dial.H>} {public
} 

decl {\#include <FL/fl_draw.H>} {public
} 

decl {\#include <FL/Fl_Tooltip.H>} {public
} 

decl {\#include <cmath>} {public
} 

decl {\#include <string>} {public
}

decl {\#include "Misc/Util.h"} {public
}

decl {\#include <FL/Fl_Group.H>} {public
} 

decl {\#include <FL/Fl_Menu_Window.H>} {public
} 

decl {using namespace std;} {public
}


class TipWin {: {public Fl_Menu_Window}
} {
  Function {TipWin():Fl_Menu_Window(1,1)} {} {
    code {
        tip.clear();
        tip = string("X.XX");
        set_override();
        end();
    } {}
  }
  Function {draw()} {return_type void
  } {
    code {draw_box(FL_BORDER_BOX, 0, 0, w(), h(), Fl_Color(175));
        fl_color(FL_BLACK);
        fl_font(labelfont(), labelsize());
        if(textmode)
            fl_draw(text.c_str(), 3, 3, w()-6, h()-6,
                    Fl_Align(FL_ALIGN_LEFT|FL_ALIGN_WRAP));
        else
            fl_draw(tip.c_str(), 3, 3, w()-6, h()-6,
                    Fl_Align(FL_ALIGN_LEFT|FL_ALIGN_WRAP));} {}
  }
  Function {value(float f)} {return_type void
  } {
    code {
        tip.clear();
        tip = asString(f);
        textmode = false;
        // Recalc size of window
        fl_font(labelfont(), labelsize());
        int W = w(), H = h();
        fl_measure(tip.c_str(), W, H, 0);
        W += 8;
        size(W, H);
        redraw();
    } {}
  }
  Function {setText(string c)} {return_type void
  } {
    code {
        text = c;
        textmode = true;
        // Recalc size of window
        fl_font(labelfont(), labelsize());
        int W = w(), H = h();
        fl_measure(text.c_str(), W, H, 0);
        W += 8;
        size(W, H);
        redraw();
    } {}
  }
  Function {setTextmode()} {return_type void
  } {
    code {
        textmode=true;
        // Recalc size of window
        fl_font(labelfont(), labelsize());
        int W = w(), H = h();
        fl_measure(text.c_str(), W, H, 0);
        W += 8;
        size(W, H);
        redraw();
    } {}
  }
  #decl {char tip[40];} {}
  decl {string tip;} {}
  decl {bool textmode;} {}
  decl {string text;} {}
}

class WidgetPDial {: {public Fl_Dial}
} {
  Function {WidgetPDial(int x,int y, int w, int h, const char *label=0):Fl_Dial(x,y,w,h,label)} {} {
    code {
        callback(value_cb, (void*)this);
        Fl_Group *save = Fl_Group::current();
        tipwin = new TipWin();
        tipwin->hide();
        Fl_Group::current(save);
        oldvalue = 0.0;
        pos = false;
        textset = false;
    } {}
  }
  Function {~WidgetPDial()} {} {
    code {delete tipwin;} {}
  }
  Function {handle(int event)} {return_type int
  } {
    code {
        double dragsize, v, min = minimum(), max = maximum();
        int my;
        switch (event)
        {
            case FL_PUSH:
                 oldvalue = value();
            case FL_DRAG:
                 if(!pos)
                 {
                     tipwin->position(Fl::event_x_root(), Fl::event_y_root() + 20);
                     pos = true;
                 }
                 tipwin->value(value());
                 tipwin->show();
                 my = -(Fl::event_y() - y() - h() / 2);

                 dragsize = 200.0;
                 if (Fl::event_state(FL_BUTTON1) == 0)
                     dragsize *= 10;
                 v = oldvalue + my / dragsize * (max - min);
                 if (v < min)
                     v = min;
                 else if (v > max)
                     v = max;

                 // printf("%d   %g    %g\\n",my,v,oldvalue);
                 value(v);
                 value_damage();
                 if (this->when() != 0)
                     do_callback();
                 return 1;
                 break;
            case FL_ENTER:
                 if(textset)
                 {
                     if(!pos)
                     {
                         tipwin->position(Fl::event_x_root(), Fl::event_y_root() + 20);
                         pos = true;
                     }
                     tipwin->setTextmode();
                     tipwin->show();
                     return 1;
                 }
                 break;
            case FL_HIDE:
            case FL_LEAVE:
                 tipwin->hide();
                 pos = false;
                 break;
            case FL_RELEASE:
                 tipwin->hide();
                 pos = false;
                 if (this->when() == 0)
                     do_callback();
                 return 1;
                 break;
        }
        return 0;
    } {selected
    }
  }
  Function {drawgradient(int cx,int cy,int sx,double m1,double m2)} {return_type void
  } {
    code {
        for (int i = (int)(m1 * sx); i < (int)(m2 * sx); ++i)
        {
            double tmp = 1.0 - powf( i * 1.0 / sx, 2.0);
            pdialcolor(140 + (int) (tmp * 90), 140 + (int)(tmp * 90), 140 + (int)(tmp * 100));
            fl_arc(cx + sx / 2 - i / 2, cy + sx / 2 - i / 2, i, i, 0, 360);
        }
    } {}
  }
  Function {draw()} {} {
    code {
        int cx = x(), cy = y(), sx = w(), sy = h();
        // clears the button face
        pdialcolor(190, 190, 200);
        fl_pie(cx - 1, cy - 1, sx + 2, sy + 2,0, 360);

        // Draws the button face (gradinet)
        drawgradient(cx, cy, sx, 0.5, 1.0);

        double val = (value() - minimum()) / (maximum() - minimum());

        // draws the scale
        pdialcolor(220, 220, 250);
        double a1 = angle1(), a2 = angle2();
        for (int i = 0; i < 12; ++i)
        {
            double a = -i / 12.0 * 360.0 - val * (a2 - a1) - a1;
            fl_pie(cx, cy, sx, sy, a + 270 - 3, a + 3 + 270);
        }
        drawgradient(cx, cy, sx, 0.0, 0.75);
        // draws the value
        double a = -(a2 - a1) * val - a1;

        // draws the max and min points
        pdialcolor(0, 100, 200);
        int xp = (int)(cx + sx / 2.0 + sx / 2.0 * sinf(angle1() / 180.0 * PI));
        int yp = (int)(cy + sy / 2.0 + sy / 2.0 * cosf(angle1() / 180.0 * PI));
        fl_pie(xp - 2, yp - 2, 4, 4, 0, 360);

        xp = (int)(cx + sx / 2.0 + sx / 2.0 * sinf(angle2() / 180.0 * PI));
        yp = (int)(cy + sy / 2.0 + sy / 2.0 * cosf(angle2() / 180.0 * PI));
        fl_pie(xp - 2, yp - 2, 4, 4, 0, 360);

        fl_push_matrix();

        fl_translate(cx + sx / 2, cy + sy / 2);
        fl_rotate(a - 90.0);

        fl_translate(sx / 2, 0);

        fl_begin_polygon();
        pdialcolor(0, 0, 0);
        fl_vertex(-10, -4);
        fl_vertex(-10, 4);
        fl_vertex(0, 0);
        fl_end_polygon();
        fl_pop_matrix();
    } {}
  }
  Function {pdialcolor(int r,int g,int b)} {} {
    code {
        if (active_r())
            fl_color(r, g, b);
        else
            fl_color(160 - (160 - r) / 3, 160 - (160 - b) / 3, 160 - (160 - b) / 3);
    } {}
  }
  Function {value_cb2()} {return_type void
  } {
    code {tipwin->value(value());} {}
  }
  Function {value_cb(Fl_Widget*, void*data)} {return_type {static void}
  } {
    code {WidgetPDial *val = (WidgetPDial*)data;
        val->value_cb2();} {}
  }
  Function {tooltip(const char * c)} {return_type void
  } {
    code {
        tipwin->setText(c);
        textset = true;
    } {}
  }
  decl {bool textset;} {}
  decl {bool pos;} {}
  decl {double oldvalue;} {}
  decl {TipWin *tipwin;} {}
} 
