# data file for the Fltk User Interface Designer (fluid)
version 1.0403
header_name {.h}
code_name {.cc}
comment {MasterUI.h} {not_in_source in_header
}

comment {MasterUI.cc} {in_source not_in_header
}

comment {Original ZynAddSubFX author Nasca Octavian Paul
Copyright (C) 2002-2005 Nasca Octavian Paul
Copyright 2009-2011, Alan Calvert
Copyright 2014-2025, Will Godfrey

This file is part of yoshimi, which is free software: you can redistribute
it and/or modify it under the terms of the GNU General Public
License as published by the Free Software Foundation; either version 2 of
the License, or (at your option) any later version.

yoshimi is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.   See the GNU General Public License (version 2 or
later) for more details.

You should have received a copy of the GNU General Public License along with
yoshimi; if not, write to the Free Software Foundation, Inc., 51 Franklin
Street, Fifth Floor, Boston, MA  02110-1301, USA.

This file is a derivative of the ZynAddSubFX original.

} {selected in_source in_header
}

decl {\#include <string>} {public local
}

decl {\#include <iostream>} {public local
}

decl {\#include "UI/MiscGui.h"} {public local
}

decl {\#include "UI/WidgetCheckButton.h"} {public local
}

decl {\#include "EffUI.h"} {public local
}

decl {\#include "BankUI.h"} {public local
}

decl {\#include "MasterUI.h"} {private global
}

decl {\#include "UI/WidgetMWSlider.h"} {private global
}

decl {\#include "Misc/SynthEngine.h"} {public local
}

decl {\#include <FL/Fl_Menu_Bar.H>} {public global
}

decl {\#include <FL/fl_draw.H>} {private global
}

decl {\#define MIN_DB -48.0} {public local
}

decl {\#define NO_DB -68.0} {public local
}

decl {\#include "Misc/NumericFuncs.h"
    using func::asDecibel;} {private local
}

decl {\#include "Misc/FormatFuncs.h"
    using func::asString;} {private local
}

class VUMeter {: {public Fl_Box}
} {
  Function {VUMeter(int x,int y, int w, int h, const char *label=0):Fl_Box(x,y,w,h,label)} {} {
    code {npart=-1;} {}
  }
  Function {init(int part_, SynthEngine *_synth)} {} {
    code {// the "part_" parameters sets the part (if it is >=0), else it sets the master
    synth = _synth;
    label(NULL);
    tick500 = 0;
    npart = part_;
    oldpeakl = 0;
    oldpeakr = 0;
    oldrmsdbl = 0.0;
    oldrmsdbr = 0.0;
    maxdbl = NO_DB;
    maxdbr = NO_DB;
    clipped = 0;
//////////////////////////////////////////////////////////OOO Strip-down Mixer Panel is dismantled
    ;} {}
  }
  Function {fetchData(float value, int control, int part, int kititem = UNUSED, int engine = UNUSED, int insert = UNUSED, int parameter = UNUSED, int offset = UNUSED, int miscmsg = UNUSED)} {return_type float
  } {
    code {//
        return collect_readData(synth, value, control, part, kititem, engine, insert, parameter, offset, miscmsg);} {}
  }
  Function {draw_master()} {} {
    code {//
            int ox = x();
            int oy = y();
            int lx = w();
            int ly = h();
            float dbl = asDecibel(fetchData(0, MAIN::control::readMainLRpeak, TOPLEVEL::section::main, 0));
            float dbr = asDecibel(fetchData(0, MAIN::control::readMainLRpeak, TOPLEVEL::section::main, 1));
            float rmsdbl = asDecibel(fetchData(0, MAIN::control::readMainLRrms, TOPLEVEL::section::main, 0));
            float rmsdbr = asDecibel(fetchData(0, MAIN::control::readMainLRrms, TOPLEVEL::section::main, 1));

            clipped = clipped | (dbl > 0) | ((dbr > 0) << 1);
            if (dbl > 0.5f)
                dbl = 0.5f;
            if (dbr > 0.5f)
                dbr = 0.5f;

            if (dbl > maxdbl)
                maxdbl = dbl;
            if (dbr > maxdbr)
                maxdbr = dbr;

            dbl = (MIN_DB - dbl) / MIN_DB;
            if (dbl < 0.0)
                dbl = 0.0;
            else if (dbl > 1.0)
                dbl = 1.0;
            dbr = (MIN_DB - dbr) / MIN_DB;
            if (dbr < 0.0)
                dbr = 0.0;
            else if (dbr > 1.0)
                dbr = 1.0;
\#          define VULENX (lx-35)
\#          define VULENY (ly/2-3)
            dbl *= VULENX;
            dbr *= VULENX;
            oldpeakl = (int)dbl;
            oldpeakr = (int)dbr;

            // compute RMS - start
            rmsdbl = ((MIN_DB - rmsdbl) / MIN_DB);
            if (rmsdbl < 0.0)
                rmsdbl = 0.0;
            else if (rmsdbl >  1.0)
                rmsdbl =  1.0;
            rmsdbr = ((MIN_DB - rmsdbr) / MIN_DB);
            if (rmsdbr < 0.0)
                rmsdbr = 0.0;
            else if (rmsdbr >1.0)
                rmsdbr = 1.0;
            int irmsdbl = rmsdbl * VULENX;
            int irmsdbr = rmsdbr * VULENX;
            // compute RMS - end

            // draw db level
            fl_color(VU_level);
            fl_rectf(ox, oy, oldpeakl, VULENY);
            fl_rectf(ox, oy + ly / 2, oldpeakr, VULENY);

            // fill with black
            fl_rectf(ox + oldpeakl, oy, VULENX - oldpeakl, VULENY, graph_back);
            fl_rectf(ox + oldpeakr, oy + ly / 2, VULENX - oldpeakr, VULENY, graph_back);

            // draw scale
            float tmp = VULENX * 1.0 / MIN_DB;
            for (int i = 1; i < 1 - MIN_DB; ++i)
            {
                int tx = VULENX + (int)(tmp * i);
                fl_color(VU_bar_1dB);
                fl_rectf(ox + tx, oy, 1, VULENY + ly / 2);
                if (i % 5 == 0)
                {
                    fl_color(VU_bar_5dB);
                    fl_rectf(ox + tx, oy, 1, VULENY + ly / 2);
                }
                if (i % 10 == 0)
                    fl_rectf(ox + tx - 1, oy, 2, VULENY + ly / 2, VU_bar_10dB);
            }

            // mellow yellow rms indicator
            if (irmsdbl)
                fl_rectf(ox + irmsdbl - 1, oy, 3, VULENY, VU_rms);
            if (irmsdbr)
                fl_rectf(ox + irmsdbr - 1, oy + ly / 2, 3, VULENY, VU_rms);

            // see red if clipped
            if (clipped & 1)
                fl_rectf(ox + VULENX + 2, oy, lx - VULENX - 3, ly / 2 - 3, VU_over);
            else
                fl_rectf(ox + VULENX + 2, oy, lx - VULENX - 3, ly / 2 - 3, graph_back);

            if (clipped & 2)
                fl_rectf(ox + VULENX + 2, oy + ly / 2, lx - VULENX - 3, (ly - 2) / 2 - 2, VU_over);
            else
                fl_rectf(ox + VULENX + 2, oy + ly / 2, lx - VULENX - 3, (ly - 2) / 2 - 2, graph_back);

            // show maxdB
            static char tmpstr[8];
            const char *dbtag = "dB";

            if ((maxdbl > NO_DB))
            {
                fl_font(FL_HELVETICA | FL_BOLD, 9);
                fl_color(VU_text);
                snprintf(tmpstr, 7, "%+3.f%s", maxdbl + 0.5f, dbtag);
                fl_draw(tmpstr, ox + VULENX + 1, oy + 1,
                    lx - VULENX - 4, VULENY - 2, FL_ALIGN_RIGHT, NULL, 0);
            }

            if ((maxdbr > NO_DB))
            {
                fl_font(FL_HELVETICA | FL_BOLD, 9);
                fl_color(VU_text);
                snprintf(tmpstr, 7, "%+3.f%s", maxdbr + 0.5f, dbtag);
                fl_draw(tmpstr, ox + VULENX + 1, oy + ly / 2 + 1,
                    lx - VULENX - 4, VULENY, FL_ALIGN_RIGHT, NULL, 0);
            }} {}
  }
  Function {draw_part()} {} {
    code {//
/////////////////////////////////////////OOO Strip-down : all parts are gone ....
  ;} {}
  }
  Function {tickdraw(VUMeter *o)} {return_type {static void}
  } {
    code {o->redraw();} {}
  }
  Function {tick(void *v)} {return_type {static void}
  } {
    code {//
    tickdraw((VUMeter *) v);
    Fl::add_timeout(0.033333333, tick, v); // 1.0 / 30.0 => 30 fps} {}
  }
  decl {int tick500;} {private local
  }
  decl {int npart;} {private local
  }
  decl {float oldrmsdbl;} {private local
  }
  decl {float oldrmsdbr;} {private local
  }
  decl {float maxdbl;} {private local
  }
  decl {float maxdbr;} {private local
  }
  decl {int oldpeakl;} {private local
  }
  decl {int oldpeakr;} {private local
  }
  decl {int clipped;} {private local
  }
  decl {int *plgroup;} {public local
  }
  decl {SynthEngine *synth;} {private local
  }
}

class SysEffSend {: {public WidgetPDial}
} {
  Function {SysEffSend(int x,int y, int w, int h, const char *label=0):WidgetPDial(x,y,w,h,label)} {} {
    code {neff1=0; neff2=0;} {}
  }
  Function {init(int neff1_, int neff2_, SynthEngine *_synth)} {} {
    code {//
        synth = _synth;
        neff1 = neff1_;
        neff2 = neff2_;
        minimum(0);
        maximum(127);
        step(1);
        labelfont(0);
        labelsize(11);
        align(FL_ALIGN_TOP);
        value(synth->Psysefxsend[neff1][neff2]);
        copy_label((asString(neff1 + 1) + "->" + asString(neff2 + 1)).c_str());} {}
  }
  Function {~SysEffSend()} {} {
    code {hide();} {}
  }
  Function {handle(int event)} {return_type int
  } {
    code {//
    if (event == FL_PUSH || event == FL_DRAG || event == FL_MOUSEWHEEL)
        collect_writeData(synth, value(), 0, (TOPLEVEL::type::Write | TOPLEVEL::type::Integer), neff2, TOPLEVEL::section::systemEffects, UNUSED, neff1, TOPLEVEL::insert::systemEffectSend);
    return WidgetPDial::handle(event);} {}
  }
  decl {int neff1;} {private local
  }
  decl {int neff2;} {private local
  }
  decl {SynthEngine *synth;} {private local
  }
}
